Having a sitemap for your website is essential. There are lots of plugins and websites out there that can generate a simple sitemap for you. I built this site using <a href=”https://nuxtjs.org/” target=”_blank” rel=”external noopener”>NuxtJS</a> and am using <a href=”https://www.npmjs.com/package/@nuxtjs/sitemap” target=”_blank” rel=”external noopener”>@nuxt/sitemap</a> which does a fair job generating a simple sitemap for your site. The problem with this solution is that the sitemap generated is incredibly simple and won’t do much for your site’s SEO. After a couple of hours of experimenting, I was able to enhance the sitemap that the plugin generates and today I will share my solution with you!

## Why Not Contribute to the Project

Let’s go ahead and get the obvious question out of the way: “Why didn’t you pull down this library, add your solution, and submit a PR for your changes?” Well, that was my initial intention. If you look at the <a href=”https://github.com/nuxt-community/sitemap-module” target=”_blank” rel=”external noopener”>nuxt-community/sitemap-module github page</a> you will see that there are 5 open issues and a PR open for generating multiple sitemaps (at least at the time of this writing). There are two main contributors working on this project, they don’t seem to be too active on it, and with that kind of queue in front of me, I decided to roll my own solution.

I’ve contributed to open source in the past and will again, but I can also tell you it takes time to get your changes merged. First, you’ve got to wrap your brain around the project’s code to gain a thorough understanding of what it is doing. You don’t want to start throwing code at something without knowing what side effects it can cause, and you have to understand how it is working to make the best contribution possible. If you make it past that hurdle, then you usually have to deal with tests. There is the chance that the developers are using a testing suite you’ve never used which means you will end up reading docs. Even if you have used it, you will still have to take the time to write the tests. Even if you can quickly add your changes and write tests, you then have to submit the PR and wait for the developers to review and merge it. I am trying to get this site to a more polished state quickly and do not want to spend the extra time required to contribute to this project right now. That might be something I circle back to at some point. Call me selfish!

## An Overview of My Solution

The solution I came up with is specific to my exact needs but could easily be catered to your own needs with a few small changes. Since I created a custom blog setup, my solution is broken into two main parts: generating the XML for the main views and generating the XML for the blogs. If you are doing something similar, then this is the solution for you! Otherwise, you can still use the part that generates the extra sitemap xml for the main views for your own project with some small changes.

I created a <a href=”https://nodejs.org/en/” target=”_blank” rel=”external noopener”>NodeJS</a> script that does all the heavy lifting and named it 'sitemapGenerate.js’. The script needs to be run after the sitemap plugin generates the simple sitemap.xml file as it uses this as a starter. Approaching things this way means that my script doesn‘t have to figure out which views exist as the plugin does that for me. My script only has to add to what is already generated after the 'nuxt generate’ task has been completed. After reading this article, you might notice that I am generating a lot of XML and it will seem like I might not have needed to approach things this way. Honestly, I did things this way in case I add more views to my site at a later point as I believe this will still be helpful.

## Setting Everything Up

As with most modern JavaScript solutions, we need to install some <a href=”https://www.npmjs.com/” target=”_blank” rel=”external noopener”>npm</a> packages. Create your script file in the root of your project (I named mine ‘sitemapGenerate.js’) and run the follwing command:

`npm i -S cheerio xml-js’`

If have a blog setup in your Nuxt project that uses markdown files to generate your views like I am doing, then you will also need the following:

`npm i -S marked esm`

You might already have <em>marked</em> installed if your blog is generated from markdown so ignore that installation if that is the case.

Here’s a brief overview of why we need these modules:
- <a href=”https://www.npmjs.com/package/cheerio" target=”_blank” rel=”external noopener”><em>cheerio</em></a>: to parse the HTML files generated by Nuxt. Also, if using a markdown driven blog setup, this will parse the HTML generated by your markdown.
- <a href=”https://www.npmjs.com/package/xml-js" target=”_blank” rel=”external noopener”><em>xml-js</em></a>: to turn your sitemap XML into JSON then to turn your JSON back to XML before you write your sitemap.xml file.
- <a href=”https://www.npmjs.com/package/marked" target=”_blank” rel=”external noopener”><em>marked</em></a>: to parse markdown into HTML.
- <a href=”https://www.npmjs.com/package/esm" target=”_blank” rel=”external noopener”><em>esm</em></a>: If you have ES6 modules exporting your blog details for Nuxt, you will need this to import those modules into the script. The other option is to use <a href=““ target=“_blank“ rel=“external noopener“>Babel</a> to transpile your script, but that requires more setup.

## Import/Require Those Dependencies!

Alright, we have to get those dependencies into the script. If you are using a blog set up, then you also need to get your blogs’ modules imported. At the top of the script file, add the following and adjust paths to suit your specific needs:

```javascript

﻿﻿﻿﻿const esmImport = require(‘esm’)(module); // it was this or a whole babel config
const Coding = esmImport(‘./content/directory/coding’);
const Gaming = esmImport(‘./content/directory/gaming’);
const cheerio = require(‘cheerio’);
const path = require(‘path’);
const fs = require(‘fs’);
const marked = require(‘marked’);
const convert = require(‘xml-js’);
const util = require(‘util’);

// array of coding blogs from content/directory/coding.js
const codingArr = Coding.default().map(item => {
  return { url: `/blog/coding/${item.slug}`, item };
});
// array of gaming blogs from content/directory/gaming.js
const gamingArr = Gaming.default().map(item => {
  return { url: `/blog/gaming/${item.slug}`, item };
});
const posts = [...codingArr, ...gamingArr];
// declare here & hoist later because requiring now would try to load sitemap.xml before it exists
let sitemapXml, sitemapJson, smUrls;
```

To briefly go over this, I’m importing 'esm’ as ‘const esmImport’ and invoking it with the ‘module’ argument. ‘const Coding’ & ‘const Gaming’ are my two ES6 blog modules and I am using 'esmImport’ to bring them into a NodeJS script without using Babel. ‘const cheerio’, ‘const marked’, & ‘const convert’ are bringing in the other npm packages we installed earlier. ‘const path’, ‘const fs’, & ‘const util’ are importing modules that are built into NodeJS.

‘const codingArr’ & ‘const gamingArr’ is where I am making arrays from my blog modules. The ‘url’ attribute just allows me to add the full url as a string and I assign the ‘item’ attribute as the entire item from the array so I have everything I need later. From here I have ‘const posts’ which is just where I combine the gaming and coding blog arrays into one, flat array.

To end this section I have ‘let sitemapXml, sitemapJson, smUrls’ because they can’t yet be assigned but need to be global. I hoist those variables later once I invoke the script. The reasoning here is because I run this from a npm script and, if these variables are defined before the script is invoked, the process will throw an exception. This is because this script will be loaded as soon as the npm script begins and the sitemap.xml generated by the Nuxt plugin won’t yet exist, but Node will try to declare these variables immediately. We have to wait until this script is actually invoked to define these variables since that happens after the ‘nuxt generate’ process has ended.﻿﻿

## Generating Sitemap XML from Your Views

Now it is time to write the function that will generate the additional XML for your main views. Go ahead and add:

```javascript
function makeSitemapForPages() {
  return new Promise(resolve => {

  });
}
```

I am returning a promise here because I need this to finish running before I write the generated result to the sitemap.xml file. You can pass reject here and do some error handling or exit the process, but I chose not to considering this will be run in the build process and, if an error is thrown, the build will just fail and I can review the problem and make the necessary changes. Since I am using this for my own static site hosted by <a href=“https://www.netlify.com/“ target=“_blank“ rel=“external noopener“>Netlify</a>, I get an email if the deployment fails, and I can visit the issue on my own time. If this were being used for something with much more weight (a work project, web application with thousands of users, etc) I would add the reject functionality. I am sometimes lazy with my own personal projects. Isn’t the saying something like “the plumber’s pipes are always clogged”?

At the top of this function, I create a variable I named ‘xml’ and assigned it to this:

```javascript
﻿// built is path for generated html file; raw is array of component vue files that makeup the generated html
    const xml = [
      {
        built: ‘index.html’,
        raw: [‘pages/index.vue’, ‘components/NavBar.vue’, ‘components/Social.vue’]
      },
      {
        built: ‘about/index.html’,
        raw: [
          ‘pages/about.vue’,
          ‘components/about/contact.vue’,
          ‘components/about/general.vue’,
          ‘components/about/site.vue’,
          ‘components/about/tech.vue’,
          ‘components/about/work.vue’
        ]
      },
      { built: ‘blog/index.html’, raw: [‘pages/blog/index.vue’] },
      {
        built: ‘blog/coding/index.html’,
        raw: [
          ‘pages/blog/coding/index.vue’,
          ‘components/blog/blogComments.vue’,
          ‘components/blog/blogContent.vue’,
          ‘components/blog/blogHeader.vue’,
          ‘components/blog/blogListContainer.vue’,
          ‘components/blog/blogListItem.vue’,
          ‘components/blog/blogListMaster.vue’,
          ‘components/blog/blogPostSlug.vue’
        ]
      },
      {
        built: ‘blog/gaming/index.html’,
        raw: [
          ‘pages/blog/gaming/index.vue’,
          ‘components/blog/blogComments.vue’,
          ‘components/blog/blogContent.vue’,
          ‘components/blog/blogHeader.vue’,
          ‘components/blog/blogListContainer.vue’,
          ‘components/blog/blogListItem.vue’,
          ‘components/blog/blogListMaster.vue’,
          ‘components/blog/blogPostSlug.vue’
        ]
      }﻿
```
This is essentially an array of objects where the ‘built’ key contains the path to the Nuxt generated HTML file for the view and the ‘raw’ key contains an array of the components that make up that view.﻿